<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ajedrez IA — Minimax + Poda Alfa-Beta</title>
<style>
  body {
    background: radial-gradient(circle at center, #0b1523 0%, #101b28 100%);
    color: #fff;
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    margin: 0;
  }

  h1 { margin-bottom: 10px; }

  .board {
    display: grid;
    grid-template-columns: repeat(8, 70px);
    border: 3px solid #111;
    border-radius: 8px;
  }

  .cell {
    width: 70px; height: 70px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 42px;
    cursor: pointer;
    transition: 0.2s;
  }

  /* Nuevos colores del tablero */
  .white { background: #d8c7a8; }   /* beige claro */
  .black { background: #4a5568; }   /* gris azulado oscuro */

  .selected { outline: 3px solid yellow; }

  /* Color rojo para los movimientos posibles */
  .highlight { box-shadow: inset 0 0 0 4px rgba(239,68,68,0.8); }
</style>
</head>
<body>
  <h1>♟️ Ajedrez — IA con Minimax + Poda Alfa-Beta</h1>
  <p>Selecciona una pieza blanca para ver sus posibles movimientos (en rojo).</p>
  <div class="board" id="board"></div>

<script>
const boardEl = document.getElementById("board");
let board = [];
let selected = null;
let highlights = [];
let turn = "white";

const startBoard = [
  ["♜","♞","♝","♛","♚","♝","♞","♜"],
  ["♟","♟","♟","♟","♟","♟","♟","♟"],
  ["","","","","","","",""],
  ["","","","","","","",""],
  ["","","","","","","",""],
  ["","","","","","","",""],
  ["♙","♙","♙","♙","♙","♙","♙","♙"],
  ["♖","♘","♗","♕","♔","♗","♘","♖"]
];

function isWhite(p){return "♙♖♘♗♕♔".includes(p);}
function isBlack(p){return "♟♜♞♝♛♚".includes(p);}

function render(){
  boardEl.innerHTML="";
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const cell=document.createElement("div");
      cell.className="cell "+((r+c)%2==0?"white":"black");
      cell.dataset.row=r; cell.dataset.col=c;
      cell.textContent=board[r][c];
      if(selected && selected.r===r && selected.c===c) cell.classList.add("selected");
      if(highlights.some(h=>h.r===r && h.c===c)) cell.classList.add("highlight");
      cell.onclick=()=>onClick(r,c);
      boardEl.appendChild(cell);
    }
  }
}

function onClick(r,c){
  const piece=board[r][c];
  if(turn==="white"){
    if(selected){
      const move=highlights.find(h=>h.r===r && h.c===c);
      if(move){
        movePiece(selected, {r,c});
        clearSelection();
        turn="black";
        render();
        setTimeout(aiMove,500);
        return;
      }
      if(piece && isWhite(piece)){
        selectPiece(r,c);
      }else{
        clearSelection();
      }
    }else if(piece && isWhite(piece)){
      selectPiece(r,c);
    }
  }
}

function selectPiece(r,c){
  selected={r,c};
  highlights=getMoves(r,c);
  render();
}

function clearSelection(){
  selected=null;
  highlights=[];
  render();
}

function movePiece(from,to){
  board[to.r][to.c]=board[from.r][from.c];
  board[from.r][from.c]="";
}

function getMoves(r,c){
  const moves=[];
  const piece=board[r][c];
  if(piece==="♙"){
    if(r>0 && !board[r-1][c]) moves.push({r:r-1,c});
    if(r===6 && !board[5][c] && !board[4][c]) moves.push({r:4,c});
    if(r>0 && c>0 && isBlack(board[r-1][c-1])) moves.push({r:r-1,c:c-1});
    if(r>0 && c<7 && isBlack(board[r-1][c+1])) moves.push({r:r-1,c:c+1});
  }else if("♖♘♗♕♔".includes(piece)){
    const dirs=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
    for(const [dr,dc] of dirs){
      const nr=r+dr, nc=c+dc;
      if(nr>=0 && nr<8 && nc>=0 && nc<8){
        const target=board[nr][nc];
        if(!target || isBlack(target)) moves.push({r:nr,c:nc});
      }
    }
  }
  return moves;
}

// --- IA (Minimax + Alfa-Beta simplificada) ---
function aiMove(){
  const moves=getAllMoves(board,"black");
  if(moves.length===0) return;
  let best=-Infinity,bestMove=null;
  for(const m of moves){
    const copy=structuredClone(board);
    moveOn(copy,m.from,m.to);
    const val=minimax(copy,2,false,-Infinity,Infinity);
    if(val>best){best=val;bestMove=m;}
  }
  if(bestMove){
    movePiece(bestMove.from,bestMove.to);
    turn="white";
    render();
  }
}

function moveOn(b,from,to){
  b[to.r][to.c]=b[from.r][from.c];
  b[from.r][from.c]="";
}

function getAllMoves(b,color){
  const arr=[];
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const p=b[r][c];
      if(!p) continue;
      if(color==="white"&&!isWhite(p))continue;
      if(color==="black"&&!isBlack(p))continue;
      const dirs=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
      for(const [dr,dc] of dirs){
        const nr=r+dr, nc=c+dc;
        if(nr>=0 && nr<8 && nc>=0 && nc<8){
          const t=b[nr][nc];
          if(!t || (color==="white"?isBlack(t):isWhite(t))){
            arr.push({from:{r,c},to:{r:nr,c:nc}});
          }
        }
      }
    }
  }
  return arr;
}

function evaluate(b){
  const val={"♙":1,"♖":5,"♘":3,"♗":3,"♕":9,"♔":100,"♟":-1,"♜":-5,"♞":-3,"♝":-3,"♛":-9,"♚":-100};
  let s=0; for(const row of b) for(const p of row) s+=(val[p]||0);
  return s;
}

function minimax(b,depth,isMax,alpha,beta){
  if(depth===0) return evaluate(b);
  if(isMax){
    let best=-Infinity;
    for(const m of getAllMoves(b,"black")){
      const copy=structuredClone(b);
      moveOn(copy,m.from,m.to);
      const val=minimax(copy,depth-1,false,alpha,beta);
      best=Math.max(best,val);
      alpha=Math.max(alpha,val);
      if(beta<=alpha) break;
    }
    return best;
  }else{
    let best=Infinity;
    for(const m of getAllMoves(b,"white")){
      const copy=structuredClone(b);
      moveOn(copy,m.from,m.to);
      const val=minimax(copy,depth-1,true,alpha,beta);
      best=Math.min(best,val);
      beta=Math.min(beta,val);
      if(beta<=alpha) break;
    }
    return best;
  }
}

board=structuredClone(startBoard);
render();
</script>
</body>
</html>
